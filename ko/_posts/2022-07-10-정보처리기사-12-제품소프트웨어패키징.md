---
################################### 게시 글 필수 정보 설정 ###################################

# 동일한 내용의 영어와 한국어 파일은 lng_pair(id)값 일치
lng_pair: id_it_12
# 제목 설정 (사용 언어로 작성)
title: 정보처리기사 - 12. 제품 소프트웨어 패키징
# 카테고리 설정 (1개)
category: 개인공부
# 태그 설정 ([태그1, 태그2, ...])
tags: [정보처리기사] 
# 저자 설정 (생략 가능) _data/owner .name 값으로 자동 설정
#author: 

# 섬네일 이미지
img: ":information.jpg" 
# 작성 날짜 설정 (YYYY-MM-DD HH:MM:SS +0900)
date: 2022-07-10 09:00:00 +0900

################################### 게시 글 기타 정보 설정 ###################################
# 댓글 비활성화 여부
comments_disable: false

# image_viewer_posts = false 혹은 image_lazy_loader_posts = false인 경우에만 사용
#image_viewer_on: true
#image_lazy_loader_on: true

# 사이트에서 검색하기 혹은 검색 엔진 제외 설정 
#on_site_search_exclude: true
#search_engine_exclude: true

# 페이지 비활성화 설정 (혹은 삭제하면 됨)
published: false

##########################################################################################
# 👇 본격적으로 글을 작성하면 됩니다. 

---
<!-- outline-start -->

소비자에게 완성된 SW 제품을 잘 포장해서 드려보자!

<!-- outline-end -->

## Ch01 제품 소프트웨어 패키징하기

* Product Software Packaging
* 개발이 완료된 제품 소프트웨어를 고객에게 전달하기 위한 형태로 포장하는 과정

<br>

* 특성
    * 전체 내용을 포함하는 메뉴얼 (설치와 사용에 필요한 과정, 환경 등)
    * 고객 중심 (개발자 중심 X)
    * 버전 관리와 릴리즈 노트 (신규/변경 이력을 확인하고 지속적으로 관리) 해야 고객도 편함
    * 모듈화 (개발할 때부터 모듈 단위로 작업)

<br>

### 1. 모듈 빌드

* 제품 소프트웨어 패키징은 모듈로 진행
* 모듈의 개념을 정확하게 이해하고, 기능 단위로 패키징 하는 것이 중요
* 따라서 최초 소스 개발 시 모듈화를 통해 제품 소프트웨어 패키징
* 배포 전에도 시험, 수정 과정에서 모듈 단위로 작업을 진행할 것

<br>

* 모듈이란?
    * 소프트웨어 설계에서 **기능 단위**로 분해하고 추상화되어 **재사용 및 공유 가능**한 수준으로 만들어진 단위
* <span style="color:#006dd7"> 모듈화(Modulation)란? </span>
    * 모듈을 이용하여 소프트웨어의 성능을 향상시키거나 시스템의 디버깅, 시험, 통합 및 수정을 용이하게 하는 것입니다.
        * 모듈 간 결합도는 최소화(Loose Coupling), 모듈 내 응집도는 최대화(Strong Cohension)할수록 좋습니다.

        <br>

    * 장점
        1. 개발 편의성
            * 프로그램을 효율적으로 관리
            * 전체적인 소프트웨어 이해의 용이성 증대
            * 소프트웨어 시험, 통합, 수정 시 용이성 제공
            * 모듈의 재사용 가능으로 개발과 유지보수가 용이
            * 오류의 파급 효과를 최소화
        2. 복잡성 감소
            * 기능의 분리, 단순한 인터페이스, 성능 향상
 
    <br>

* 모듈 빌드 기법
    * 소프트웨어 빌드는 소스 코드 파일을 제품 소프트웨어 단위로 변환하는 것 (컴퓨터에서 실행 가능)
    * 빌드 도구: Ant, Make, Maven, Gradle 등
    * 빌드 과정 문서화하면 이력 관리도 가능

    <br>
    <hr>



### 2. 사용자 중심 패키징

* 제품 소프트웨어 패키징은 **사용자를 위해 진행되는 작업**
* 사용자 입장에서 생각하고 패키징하자. (고객 편의성, 사용자 실행 환경)

<br>

* 고려사항
    * (시스템 환경) OS, CPU, Memory 수행하기 위한 최소 환경
    * (직관적 UI)  메뉴얼과 일치시켜 패키징 진행
    * (관리 서비스) HW와 함께 통합 적용할 수 있도록 제공
    * (안정적 배포) 고객의 편의성이 우선, 다양한 요구사항 반영하여 항상 패키징의 변경 및 개선 관리를 고려

    <br>

* 프로세스
    1. 기능 식별: 입출력 데이터, 전체적인 기능, 데이터 흐름, 기능 단위, 출력 상세
    2. 모듈화: 기능 및 서비스를 모듈 단위로 분류, 기능 공유, 재활용 분류, 모듈 간 결합도와 응집도 식별 
        * 결합도(Coupling): 모듈 간 연관성, 낮을수록 좋음
        * 응집도(Cohesion): 모듈의 독립성, 하나의 모듈 내부 처리 요소 간의 기능적 연관도, 높을수록 좋음
    3. 빌드 진행: 신규 개발 소스 및 컴파일 결과물 준비, 정상 기능 단위 및 서비스 분류, 빌드 도구 확인 및 정상 수행, 컴파일 이외 도구의 다양한 기능 확인
    4. 사용자 환경 분석: 최소 사용자 환경 사전 정의, 모듈 단위에 사용자 환경 테스트 수행
    5. 패키징 적용 시험: 사용자 환경에서 진행하고 UI 및 시스템 상의 편의성 체크
    6. 패키징 변경 개선: 변경점 도출, 개선 버전 재배포

<br>
<hr>



### 3. 버전을 고려한 제품 릴리즈 노트 작성

#### 릴리즈 노트
![img_23](https://user-images.githubusercontent.com/105165938/178816203-0705cdd7-d898-4d64-af89-18d29d968a3a.png)<br>
*© 이미지 출처: https://tech.kakaoenterprise.com/113*

* 개념
    * 고객에게 개발 과정에서 정리된 제품의 릴리즈 정보를 제공하는 문서
    * 릴리즈 정보에는 상세 서비스, 제품의 수정, 변경, 개선의 일련의 작업 정보가 들어감
* 중요성
    * (정보 제공) 사용자에게 테스트 진행 과정, 결과, 개발팀의 제공 사양 준수 정도를 명확히 제공
    * (관리 용이성) 전체적인 버전 관리 및 릴리즈 정보를 체계적으로 관리할 수 있음
    
<br>

* 고려사항
    * 현재 시제로 작성
    * 배포 시부터 신규 소스, 빌드 등의 이력 제공
    * 개발팀이 직접 작성 (개발자 + 테스터 협업)

    <br>

* 작성 항목<br>
    ![img_24](https://user-images.githubusercontent.com/105165938/178816628-9ca50b9e-c700-42a1-b7b1-fbe38aeea886.png)
    * 해더: 문서 이름(릴리즈 노트 이름), 제품 이름, 버전 번호, 날짜, 노트 버전 ..
    * 전반적 개요
    * 목적: 새로운 기능목록, 릴리즈 노트 목적, 버그 수정,
    * 이슈 요약: ⬆️ 목적 내용 요약
    * 버그 재현 항목
    * 수정, 개선 내용
    * 사용자 영향도
    * 소프트웨어 지원 영향도
    * 노트: 업그레이드 된 부분들
    * 면책 조항: 프리웨어 및 불법 복제 방지 .. 참조에 대한 고지 사항
    * 사용자 문의 연락 정보
    <br>
![img_25](https://user-images.githubusercontent.com/105165938/178817651-75029b6e-f637-43e5-b5c6-cee1e0352ddb.png)<br>
    회사마다 다르니깐, 참고할 것~<br>

<br>

* 예외 케이스 *(릴리즈 노트 항목에 추가될 수 있는 항목)*
    * 테스트 단계에서의 베타 버전 출시
    * 긴급 버그 수정 시 놓치기 쉬우니깐, 꼼꼼하게 기록하기
    * 자체 기능 향상을 포함한 모든 추가 기능의 향상 (SW, HW 모두 적용)
    * 사용자 문의에 따른 특이한 케이스 발생 시 (자체 기능 향상과는 다른 버전으로 작성)

    <br>

* 프로세스
    1. 모듈 식별
    2. 릴리즈 정보 확인
    3. 릴리즈 노트 개요 작성
    4. SW와 사용자 입장에서의 영향도 체크 (버그, 릴리즈 추가 항목, 버그 발견을 위한 재현 테스트 및 환경)
    5. 정식 릴리즈 노트 작성
    6. 추가 개선 항목 식별

<br><br>
<hr>

### 4. 제품 패키징 도구 활용
* 디지털 콘텐츠의 불법 사용, 복제 방지, 과금 서비스를 통한 정상 사용자를 검증 가능한 저작권 도구를 통해 패키징

<br>

* 고려 사항
    * 내부 콘텐츠는 암호화/ 보안 고려
    * 이기종 콘텐츠, 단말기 간 DRM 연동 고려 (패키징 도구 활용)
    * 사용자 편의성 고려
    * 적합한 암호화 알고리즘 적용 (SW 제품에 맞는 알고리즘을 써야 범용성에 지장이 없음)

<br><br>

#### 저작권 보호
* 저작권(Copyright) 이해
    * 창작물인 저작물에 대한 배타적 독점적 권리로 타인의 침해를 받지 않을 고유한 권한

    <br>

* 보호 기술
    * 개념
        * 복제가 용이한 저작물에 대한 무단 복제 및 배포 등을 보호하는 기술
    * 특성
        * 사용자 확인 -> 과금 O -> 콘텐츠 복제 제한적 허용
        * 종량제 제품 SW는 클리어링 하우스(중개자)를 통한 이용시간에 비례한 과금
        * 애초에 패키징 제작자가 지정한 Business Rule과 암호를 함께 패키징하여 배포

        <br>

    * 필요성
        * 배포된 제품 소프트웨어의 무한 복제, 원본과 동일하게 배포를 방지 (why? 부가가치를 가질 수 있음)

<br><br>


#### <span style="color:#006dd7"> 저작권 보호에 패키징 도구 활용 </span>

* DRM(Digital right Management)<br>

    * 구성요소
        * (콘텐츠 제공자)
        * (콘텐츠 소비자)
        * (콘텐츠 분배자) 암호화된 콘텐츠를 유통하는 곳 또는 사람
        * (클리어링 하우스) 저작권에 대한 사용권한, 키와 라이센스 발급, 사용량에 따른 관리 수행
            * (콘텐츠 권한 정책) 라이선스 발급 여부 결정
            * (콘텐츠 라이센스) 사용 조건, 허가 정보, 권리 인증 
        * (DRM 콘텐츠) 암호화 콘텐츠, 메타데이터, 콘텐츠 사용정보 패키징한 콘텐츠
        * (패키저) 콘텐츠를 메타데이터와 함께 배포 가능한 단위로 묶는 도구
        * (DRM 컨트롤러) 배포된 DRM 이용 권한 통제
        * (보안 컨테이너) 안전한 유통을 위한 전자적 보안장치

        <br>

    * 암호화, 보안 중심의 패키징 도구 기술 (= DRM 기술)
        * 암호화(Encryption)
            * 일반 텍스트, 콘텐츠, 라이센스 등 암호화, 전자서명 기술
            * (PK) 전자 서명된 인증서를 발급받아 네트워크상에서 안전한 비밀통신 보장
            * (대칭 및 비대칭 암호화) 사용하는 키 개수가 다름
            * (전자 서명) 서명자 확인, 서명 사실 나타내기 위해 특정 전자문서에 첨부되거나 논리적으로 결합된 전자적 형태의 정보

            <br>

        * 키 관리(Key Management)
            * 암호화한 키에 대한 저장, 배포 기술
            * 중앙 집중형
            * 분산형

        <br>

        * 식별 기술(Identification)
            * 콘텐츠 식별 체계 기술 
            * DOI(Digital Object Identifier): 저작물의 위치 추적을 위해 제작된 특정한 번호 (일종의 바코드)[참고](https://www.doi.or.kr/wordpress/about_doi/)
                * 네트워크 상의 주민등록번호 ex) URL, 이메일주소, ..
            * URI(Uniform Resource Identifier): 인터넷 자원을 고유하게 식별할 수 있는 **식별자** (URL + URN)
                * URL(Uniform Resource Locator): 웹 서버에 존재하는 자원의 주소
                * URN(Uniform Resource Name): 폴더/파일 이름 <br>
                ![img_40](https://user-images.githubusercontent.com/105165938/179101424-6229a832-9ab4-47b9-8866-1a3dcf733908.png)<br>*© 이미지 출처: https://velog.velcdn.com* <br>
                ![img_41](https://user-images.githubusercontent.com/105165938/179115742-edfd7690-c386-4f9f-8075-1391e85491d4.png)<br>*© 이미지 출처: https://waytolearnx.com/2018/09/difference-entre-uri-et-url.html*<br>

            <br>

        * 저작권 표현(Right Expression)
            * 라이센스 내용 표현 기술
            * XrML(eXtensible Right Markup Language): 웹 서비스 권리 조건을 XML 기반 마크업 언어로 표현
            * MPEG-21: 멀티미디어 관련 요소 기술들이 통일된 형태로 상호 운용성 보장

            <br>

        * 암호화 파일 생성(Packager)
            * 콘텐츠를 암호화하는 기술
            * Pre-packaging: 콘텐츠를 등록하자마자 암호화
            * On-the-fly Packaging: 사용자가 콘텐츠를 요청한 시점에 암호화

            <br>

        * 정책 관리(Policy Management)
            * 라이센스 발급 및 사용에 대한 정책표현, 관리기술
            * XML(eXtensible Markup Language): 다른 특수한 목적을 갖는 마크업 언어를 만드는 데 사용하는 다목적 언어
                * 데이터 보여주기 X, 데이터를 전달하기 O 
                * 텍스트 기반의 마크업 언어 (HTML 비슷)
                * 사람과 기계 둘 다 읽기 편함
                * 플랫폼 독립적 (다른 플랫폼 간의 전송 가능)
            * CMS(Contents Management System): 저작물 관리 소프트웨어 (콘텐츠 작성, 수집, 관리, 배급, 활용, 폐기 등)

            <br>

        * 크랙 방지(Tamper Resistance)
            * 크랙에 의한 콘텐츠 사용 방지 기술
            * 코드 난독화(Code Obfuscation): 역공학을 통한 공격 대비 (그래도 뚫릴 순 있음..)
                * 역공학(reverse engineering): 장치 또는 시스템의 기술적인 원리를 구조분석을 통해 발견하는 과정 (불법)<br>
            ![img_43](https://user-images.githubusercontent.com/105165938/179118352-f01f8a55-9629-4d18-b4d7-8eeeaec1ba4d.png)<br>*© 이미지 출처: https://www.preemptive.com/obfuscation/*
            * Secure DB: 커널 암호화 방식으로 DB 파이를 직접 암호화, 접근 제어, 감사 기록 기능이 추가<br>
                ![img_44](https://user-images.githubusercontent.com/105165938/179119989-69669013-676e-4879-99a5-02a68bbc519c.png)<br>*© 이미지 출처: https://cloud.kt.com/portal/ktcloudportal.epc.productintro.ucloud_server_image.SECUREDB.html*<br>
                * Agent: Key Server와 SSL 통신 관리 (접근 권한 제어, 감사 기록)
                * Key Server: 암호화 (컬럼 단위)
                * Admin UI: GUI를 통한 암호화
                * 현재 금융권에서 사용, x86 프로세스 기반 윈도/리눅스 서버 환경에서 도입 가능 (전문가 없어도 됨)

            
            <br>

        * 인증(Authentication)
            * 라이선스 발급 및 사용의 기준 인증 기술
            * SSO(Single Sign On): '한 번의 시스템 인증으로 여러 정보시스템을 이용하자' (통합 로그인)
                * ex) 네이버 메일, 네이버 블로그, 네이버 클라우드 ..<br>
                ![img_42](https://user-images.githubusercontent.com/105165938/179117593-285db271-9199-4b74-81b0-e4d7d4345520.png)<br>*© 이미지 출처: https://blog.naver.com/PostView.nhn?blogId=pentamkt&logNo=222188061260&parentCategoryNo=&categoryNo=19&viewDate=&isShowPopularPosts=false&from=postView* [참고](https://toma0912.tistory.com/75)<br>
                
                

<br><br>



#### 최종 배포
* 어플리케이션 배포 도구를 활용하여 배포

<br>

* 프로세스
    1. (빌드 내용 식별) 릴리즈 노트 작성을 위한 빌드 내용 식별   
    2. (패키징 도구 식별) 사전 선택, 암호/보안 기능 확인하여 패키징 도구 식별
    3. (패키징 수행) 콘텐츠 배포자, 분배자, 소비자 간 DRM 흐름을 확인하여 패키징 수행 (키, 보안 관리 확인)
    4. (배포 작업)
    5. (정상 배포 확인) 체크리스트로 암호화/보안 적용 확인하여 정상 배포 확인

<br><br>
<hr>


## Ch02 제품 소프트웨어 매뉴얼 작성 및 버전 등록

[TIP] 둘 다 비슷~ 하니깐 아! 그렇구나로 이해~~ (나로서는 공감이 많이 되었던 부분..)

### 1. 제품 소프트웨어 매뉴얼 작성

* 패키징 이후 
* 사용자 측면에서 설치, 사용하는 데 필요한 주요 내용을 기록한 문서 (설명서, 안내서)

<br>

#### 제품 소프트웨어 설치 매뉴얼 작성

* 설치할 때 참조될 문서
* 제품 소프트웨어 소개, 설치 파일, 설치 절차

<br>

* 기본 항목
    * 목차 및 개요
    * 문서 이력 정보: 매뉴얼 변경 이력을 버전별로 표시
    * 설치 매뉴얼 주석
        * (주의사항) 설치 시 반드시 숙지해야 하는 정보
        * (참고사항) 설치에 영항을 미치는 특별한 사용자 환경 및 상황
    * 설치 도구의 구성: exe / dll / ini / chm .. 설치 관련 파일, 폴더, 실행 파일에 대한 설명

<br>

* 설치 환경 체크 항목
    * (사용자 환경) Cpu, memory, OS
    * (응용 프로그램) 다른 응용프로그램은 종료
    * (업그레이드 버전) 업그레이드 이전 버전 있는지 확인
    * (백업 폴더 확인) 설치 시 동기화

<br>

* 설치 매뉴얼 구성요소
    * (제품 소프트웨어 개요) 주요 기능, UI, 버튼 & 프레임 등 도식화하여 설명
    * (설치 관련 파일) exe 파일, ini / log 파일
    * (설치 절차) 상세하게 설치 디렉토리, 위치까지 설명
    * (설치 아이콘) Window 가능
    * (삭제 방법)
    * (설치 버전 및 작성자) 릴리즈 버전
    * (고객 지원 방법 및 FAQ) 자주 발생하는 오류 및 처리 방법 요약 설명
    * (준수 정보 & 제한 보증) 시리얼 보존, 불법 등록 사용 금지 등의 준수 사항 권고 (DRM)
    * 정상 설치 완료되었습니다! 

<br>

* 설치 매뉴얼 작성 프로세스
    1. (개요 및 기능 식별) 개발 목적 및 전체적인 기능 식별
    2. (UI 분류) 설치를 위한 화면 단위 및 메뉴 분류 (작성될 순서대로 분류)
    3. (설치 파일 / 백업 파일 확인) 실제로 제품을 설치할 파일, 백업 파일의 이름과 위치, 기능 숙지
    4. (삭제 절차 확인) '설치 전 상태로 복귀하자!'
    5. (이상 유형 확인) 유형별로 발생하는 이상 현상에 대한 메시지가 정상인지 확인
    6. (최종 매뉴얼 적용) 

<br><br>
<hr>


### 2. 제품 소프트웨어 사용자 메뉴얼

* 사용자가 소프트웨어 사용에 필요한 내용, 제반 절차, 환경 등의 내용을 포함하는 문서
* 개발된 컴포넌트 사용 시 알아야 할 내용 (기능, 인터페이스, 메서드, 오퍼레이션, 파라미터 등)

<br>

* 작성 항목
    * (목차 및 개요) 전체 내용을 순서대로 요약, 주요 특징, 실행 방법, 점검 기준, 설정 방법 등
    * (문서 이력 정보) 버전, 작성자, 작성일, 검토자, 일시, 검수인 (일자별 기록)
    * (사용자 메뉴얼 주석) 
        * (주의사항) 반드시 숙지해야 하는 중요한 정보
        * (참고사항) 특별한 사용자 환경 및 상황에 대한 내용
    * (기록 항목) 제품 명칭, 모델명, 문서 번호, 제품 번호
    * (기본 사항) 개요, 사용방법, 관리방법, 모델, 버전별 특징, 기능, 인터페이스, 구동환경
    * (고객 지원 방법 및 FAQ) 
    * (준수 정보 & 제한 보증) 
    * Plus! 함께 동작하는 애플리케이션, 설치되어 충돌될 수 있는 응용 프로그램도 같이 작성해주자!

    <br>

* 작성 프로세스
    1. (작성 지침 정의) 실제 사용자 환경에 필요한 정보를 제공할 수 있는 형태로 작성
    2. (사용자 매뉴얼 구성요소 정의) 기능, 구성, 객체 목록, 객체별 메서드, 파라미터, 실제 사용 예제, 사용자 환경 세팅 방법 등
    3. (구성요소별 내용 작성) 
    4. (사용자 매뉴얼 검토) 해당 기능별 관련 개발자와 함께 검토

<br>
<hr>



### 3. 제품 소프트웨어 매뉴얼 배포용 미디어

[TIP] 얜 진~짜 공부하지 않아도 될 것 같음. WHY? 중요한 건 다 했으니깐~

#### 제품 소프트웨어 배포본

* 사용자가 사용하기 편하도록 배포 정보를 포함하여 개발된 컴포넌트 또는 패키지가 제품화된 형태

<br>

* 중요 사항
    * 사용자에게 배포해도 안전한지!
    * 저작권 및 보안에 유의
    * 고유 시리얼 넘버를 반드시 부착할 것 (복제 및 사후 지원 고려)

<br>

#### 제품 소프트웨어 메뉴얼의 배포용 미디어 제작

* 포함 항목
    * 버전 정보
    * 요구 사항
    * 설치 방법
    * 새로운 기능
    * 알려진 오류 / 대처 방법
    * 제약사항: 현재까지 개발된 시스템이 설치, 운영 상에 어떤 제약사항이 있었는지 기재

 <br>

* 제작 방법
    * 오프라인 미디어
        * CD, 시리얼넘버 포함할 것, 관리 시스템을 사전에 확보
        * 제작 단계
            1. 오프라인 미디어 준비
            2. 시리얼 넘버 확인
            3. 매뉴얼 확인: 설치 매뉴얼, 사용자 매뉴얼
            4. Install 파일 확인
            5. 제품 CD 정상 제작 및 동작 확인

     <br>

    * 온라인 미디어
        * 실행 파일로 통합하여 제작
        * 내용
            * 기능 업그레이드
            * 제품 패치
            * 기능적 오류 수정
            * OS 등의 업그레이드에 따른 호환성 제공

<br>

#### 제작하기

1. 배포용 미디어 선정
2. 관리 체계 확인: 시리얼 넘버 체계와 툴 사전 정의, 등록 및 관리 체계 수립, 시스템화 
3. 설치 파일 / 매뉴얼 확인
4. 최종 배포본 검증
5. 배포용 미디어 정보 확인 (SW, 문서 정보)
6. 최종 미디어 인증 확인 및 배포 (테스트 완료, CD)

<br><br>
<hr>


### 4. 버전 관리 도구

#### 관리 도구 활용 방향

* 보유하고 있는 제품 버전과 새로 개발된 버전을 동시에 관리
* 백업, 장애, 복구를 Case 별로 고려
    * Case: 코드, 라이브러리, 관련 문서 등 (시간의 변화에 따라 변경 내역 관리)

<br>

* 버전 현황 관리가 필요한 상황
    * 기존의 고유한 버전 관리 외에도 버전 관리 도구에서 지원하는 작업 전체를 관리
    * (버전 관리 배업 및 복구) 이전 버전으로 돌아가야할 때
    * (동일 버전 공동 작업) 분산 환경에서 동일 버전의 소스 코드를 두 명 이상의 개발자가 수정할 때
    * (여러 버전 솔루션 작업 = 브랜치 관리) 하나의 솔루션을 기반으로 여러 버전의 제품을 개발할 때

<br>

#### 제품 소프트웨어 소스 및 자료 백업

* 천재지변, 해킹, 버그, 오독장 등으로 인한 재해에 대비한 회복 가능한 상태로 만들기 위한 준비
* 손실 예방이 베스트
* 손실 발생 시 최단 기간에 정상 업무 복구할 수 있어야 함
* 그러니깐 버전 관리 도구 잘 쓰자~

<br>

* 버전 관리 도구를 이용한 백업 유형
    * 전체 백업(Full Backup): 백업받고자 하는 데이터 전체에 대해 백업
    * 차등 백업(Differential Backups):마지막 전체 백업 이후 변경된 모든 데이터를 백업
    * 증분 백업(Incremental Backup): 정해진 시간을 기준으로 그 이후에 변경된 파일만 백업

<br>

* 버전 관리 도구 활용 시 자료 백업 정책 및 방법
    1. 정책
        * 버전 관리 라이브러리에 대한 백업 파일은 버전 관리 라이브러리가 저장된 디스크와 분리된 디스크에 저장
            * 디스크 백업: 1일 1회 정해진 시간에 실시 (일요일 제외)
            * CD 백업: 1주일 1회 정해진 요일 실시
        * 실수로 삭제할 수 있으니, D-2일분 이상 보관

        <br>

    2. 방법
        * 버전 라이브러리의 빠른 복구를 위한 Full Backup 실시
        * 임시/신규 요청 또는 중지 요청은 절차가 있음
        * 백업 결과는 버전 관리자가 주기적으로 점검하여, 버전 관리 정기 보고 시 보고

        <br>

        1. 디렉토리를 신규로 만들며 물리적 복사(저장소 백업)
            * 2차 백업 개념
            * ./.Git 폴더의 내용 디렉토리를 물리적으로 다른 곳에 보관하여 백업
        2. 버전 관리 도구의 백업 기능 활용(Git 번들)
            * 레포지토리의 번들을 생성
            * 백업 자체를 버전 관리 도구가 자동화 진행

수고하셨습니다. 😆




---
################################### 게시 글 필수 정보 설정 ###################################

# 동일한 내용의 영어와 한국어 파일은 lng_pair(id)값 일치
lng_pair: id_it_11
# 제목 설정 (사용 언어로 작성)
title: 정보처리기사 - 11. 응용SW 기초기술 활용
# 카테고리 설정 (1개)
category: 정보처리기사 
# 태그 설정 ([태그1, 태그2, ...])
tags: [정보처리기사] 
# 저자 설정 (생략 가능) _data/owner .name 값으로 자동 설정
#author: 

# 섬네일 이미지
img: ":information.jpg" 
# 작성 날짜 설정 (YYYY-MM-DD HH:MM:SS +0900)
date: 2022-07-09 09:00:00 +0900

################################### 게시 글 기타 정보 설정 ###################################
# 댓글 비활성화 여부
comments_disable: false

# image_viewer_posts = false 혹은 image_lazy_loader_posts = false인 경우에만 사용
#image_viewer_on: true
#image_lazy_loader_on: true

# 사이트에서 검색하기 혹은 검색 엔진 제외 설정 
#on_site_search_exclude: true
#search_engine_exclude: true

# 페이지 비활성화 설정 (혹은 삭제하면 됨)
#published: false

##########################################################################################
# 👇 본격적으로 글을 작성하면 됩니다. 

---
<!-- outline-start -->
[정보처리기사] - 11. 운영체제, 네트워크, 기본 개발환경

<!-- outline-end -->
# 응용 SW 기초 기술 활용
## Ch01 운영체제의 특징
### 1. 운영체제 기본
* 개념<br>
    ![img_16](https://user-images.githubusercontent.com/105165938/178730539-126e44df-81cd-4d2d-9eb1-b86889e5dbf9.jpeg)<br>
    * OS; Operating System
    * 사용자가 컴퓨터의 하드웨어를 쉽게 사용할 수 있도록 인터페이스를 제공해주는 소프트웨어
    * 컴퓨터의 온갖 중요한 일은 다 OS가 합니다~
<br>

* 특징
    1. 사용자 편리성 제공: 한정된 시스템 자원을 효과적으로 사용하도록 관리
    2. 인터페이스: 컴퓨터와 사용자의 의사소통 
    3. 스케줄링: 다중 사용자, 다중 응용 프로그램 환경에서 자원의 현재 상태를 파악하고 자원 분배
    4. 자원 관리: CPU, 메모리 공간, 기억장치, 입출력 장치
    5. 제어 기능: 입출력 장치, 사용자 프로그램
<br>

* 구조<br>
    ![img_22](https://user-images.githubusercontent.com/105165938/178730554-16955de7-f667-4510-9d01-b6c57ede11e2.jpeg)<br>
    * 인터페이스(쉘)
        * 커널을 편리하게 사용할 수 있게 함(GUI)
        * 운영체제 가장자리에 위치하여 사용자의 명령을 처리
    * **커널**
        * 운영체제의 핵심적인 기능 집합
            * 프로세스 관리: 프로세스 스케줄링, 동기화, 프로세스 생성, 제거, 시작, 정지, 메시지 전달 등
            * 기억장치 관리: 프로세스에게 메모리 할당 및 회수
            * 주변장치 관리: 입출력 장치 스케줄링, 관리
            * 파일 관리: 파일 생성, 삭제, 변경, 유지, 관리
        * 하드웨어와 관련된 내부적인 역할
<br>

* 종류
    * Windows
        * made by Microsoft
        * MS-DOS 멀티태스킹: 동시에 여러 개의 프로그램을 실행하면서 운영체제가 각 작업의 CPI 이용 시간을 제어
        * GUI 제공
        * 자동감지 기능: 하드웨어 설치했을 때 필요한 시스템 환경을 운영체제가 자동으로 구성해주는 자동감지 기능 제공
        * OLE 사용(Object Linking and Embedding): 개체를 현재 작성 중인 문서에 자유롭게 연결 또는 삽입하여 편집할 수 있게 하는 기능 제공
<br>

* 유닉스(Unix)
    * 대화식 운영체제
    * 다중 작업 기능
    * 다중 사용자 기능
    * 이식성 제공
    * 계층적 트리 구조 파일 시스템

    * 리눅스
    * 맥
    * 안드로이드

### 2. 운영체제 기본 명령어 활용
* 제어
    * CLI(Command Line Interface): 사용자가 직접 명령어를 입력하여 컴퓨터에게 명령
    * GUI(Graphic User Interface): 사용자가 마우스로 그래픽 화면을 클릭하여 컴퓨터에게 명령
<br>

* 윈도즈 운영체제 기본 명령어
    * 명령창 요구
    * 잘 모르겠으면 명령창에 **Help**를 치면 도와줌 (오잉❔)
    * 파일 이동과 프로그램 실행은 GUI를 추천!
    * CUI
        * ATTRIB
        * CALL
        * CD
        * CHKDSK
        * CLS
        * CMD
        * COMP
        * DISKPART
        * ECHO
        * ERASE
        * EXIT
<br>

* 리눅스/유닉스 계열의 기본 명령어
    * 쉘에서 입력
    * 최상위 유저(**#**)와 일반 유저(**$**)를 구분
    * 잘 모르겠으면 명령어 뒤에 **--help**, **-h**를 붙이면 됨 (그니깐 난 바보임.)
    * 시스템 관련
        * uname -a
        * uname -r
        * cat
        * uptime
    * 사용자
        * id
        * last
        * who
    * 파일 처리
        * ls
        * pwd
        * rm
        * cp
        * mv
    * 프로세스
        * ps
        * pmap
        * kill
    * 파일 권한
        * chmod
        * chown
    * 네트워크
        * ifconfig
        * host
    * 압축
        * tar
        * gzip
    * 검색
        * grep
        * find
    * 파일 이동
        * cp
        * rsync
    * 디스크 사용
        * df
        * du
    * 디렉터리 이동
        * cd

### 3. 운영체제 핵심 기능 파악
* 운영체제 핵심 기능
    * 중앙처리장치, 메모리, 스토리지, 주변 기기 등을 적절히 관리
        * 예전에는 메모리 관리가 중요했지만, 이제는 자동으로 해줌
        * 클라우드화되면서 자원에 대한 관리 노력이 줄었음
    1. 메모리 관리
        * 프로그램의 실행이 종료될 때까지 메모리를 가용한 상태로 유지 및 관리
        * 프로그램 실행 중 메모리가 꽉 차게 되면 시스템의 속도가 느려지고 때로는 시스템이 멈추는 현상이 발생
    2. 프로세스 관리
        * 일시 중지 및 재실행
        * 동기화
        * 통신
        * 교착상태 처리
        * 프로세스 생성 삭제
<br>

#### 1. 메모리 관리
* 반입 기법
* 배치 기법
* 할당 기법
* 교체 기법

#### 2. 프로세스 관리
* 프로세스 상태 
    * 생성 상태
    * 준비 상태
    * 대기 상태
    * 완료 상태
<br>

* 프로세스 상태 전이
    * 디스패치
    * 타이머 런 아웃
    * 블록
    * 웨이크 업
<br>

* 프로세스 스케줄링
    * 서비스 시간
    * 응답 시간
    * 반환 시간
    * 대기 시간
    * 평균 대기시간
    * 종료시간
    * 시간 할당량
    * 응답률
<br>

* 프로세스 스케줄링 유형
    * 선점형 스케줄링
    * 비선점형 스케줄링
<br>

* 선점형 스케줄링 알고리즘
<br>

* 비선점형 스케줄링 알고리즘
<br>

* 프로세스 관리 - 교착상태
    * 교착상태(Deadlock): 다중프로세싱 환경에서 두 개 이상의 프로세스가 특정 자원할당을 무한정 대기하는 상태
    ![이미지]()
    * 발생 조건
        * 상호 배제(Mutual Exclusive): 배타적으로 점유하여 다른 프로세스가 그 자원을 사용할 수 없는 상태
        * 점유와 대기
        * 비선점
        * 환형 대기
    * 해결 방법
        * 예방
        * 회피
        * 발견
        * 복구
<br>

#### 4. 가상화, 클라우드
* 가상화(Virtualization)
    * 물리적인 리소스들을 사용자에게 하나로 보이게 하거나, 하나의 물리적인 리소스를 여러 개로 보이게 하는 기술
    * 서버는 용량의 20% 정도만 사용 -> 가상화를 통해 서버의 가동률을 60~70% 이상으로 올릴 수 있음
* 종류
    * 플랫폼 가상화
    * 리소스 가상화
* 가상화 기술 요소
    * 컴퓨팅 가상화
    * 스토리지 가상화
    * I/O 가상화
    * 컨테이너
    * 분산처리 기술
    * 네트워크 가상화 기술

* 클라우드 컴퓨팅
* 클라우드 컴퓨팅 분류
* 사설 클라우드
* 공용 클라우드
* 하이브리드 클라우드

* 클라우드 컴퓨팅 유형
    * IaaS(Infrastructure as a Service)
        * 서버, 스토리지와 같은 시스템 자원을 클라우드로 제공
    * PaaS(Platform as a Service)
        * 
    * SaaS(Software as a Service)
        * 주문형 소프트웨어

<br>
<br>
<hr>


## Ch02 네트워크 기초 활용하기
### 1. 네트워크 계층 구조
* 개념
    * 원하는 정보를 원하는 수신자 또는 기기에 정확하게 전송하기 위한 기반 인프라
        * LAN(local): 한 건물 또는 작은 지역을 커버
        * WAN: LAN에 비해 전송 거리가 넓은 만큼 에러율과 전송 지연율이 높음 (라우팅 알고리즘 필요)
<br>

* OSI(Open System Interconnection) 모델
    * 네트워크 프로토콜과 통신을 기준으로 7계층으로 나눔 
    * 각 계층은 서로 독립적으로 구성
    * 송신: 하위 7계층 -> 🎶🎶🎶🎶🎶 -> 상위 1계층 
        * 하위 계층의 기능을 이용하여 상위 계층에 기능을 제공
        * 각 계층을 지날 때마다 Header가 붙음
            * Header: 계층의 기능과 관련된 제어 정보가 들어가 있는 곳
    * 수신: 상위 1계층 -> 🎶🎶🎶🎶🎶 -> 하위 7계층
        * 각 계층을 지날 떄마다 Header가 제거됨

| 번호 | 계층 이름 | 프로토콜 | 전송단위 | 장비 | 설명 |  
|:---:|:-------:|:-----:|:------:|:---:|:----|  
| 7   | application(응용)   | HTTP, FTP | 데이터(data)    || 호스트(pc) || 사용자와 네트워크 간 응용서비스 연결, 데이터 생성|  
| 6   | presentation(표현)  | JPEG, MPEG|               ||           || 데이터 형식 설정, 부호교환, 암복호화|  
| 5   | session(세션)       | RPC, MPEG |               ||           || 송수신 간의 논리적인 연결, 연결접속, 동기제어|  
| 4   | transport(전송)     | TCP, UDP  | 세그먼트(segment)| L4 스위치    | 송수신 프로세스 간의 연결, 신뢰성 있는 통신 보장, 데이터분할, 재조립, 흐름 제어, 오류 제어, 혼잡 제어|  
| 3   | network(네트워크)    | IP, ICMP  | 패킷(packet)    | 라우터       | 단말기 간 데이터 전송을 위한 최적화된 경로 제공|  
| 2   | data link(데이터링크) | HDLC, PPP | 프레임(frame)   | 브리지, 스위치 | 인접 시스템 간 데이터 전송, 전송 오류제어, 동기화, 오류제어, 흐름제어, 회선제어|  
| 1   | physical(물리)      | PS-232C   | 비트(bit)       | 허브, 리피터  | 0과 1의 비트 정보를 회선에 보내기 위한 전기적 신호 변환|  

<br>

* 네트워크 장비
    * 1계층 장비
        * 허브: 여러 대의 컴퓨터를 연결하여 네트워크로 보내거나, 하나의 네트워크로 수신된 여러 대의 컴퓨터로 송신하기 위한 장비
        * 리피터: 디지털 신호를 증폭시켜 주는 역할을 하거나 역할을 하여 신호가 약해지지 않고 컴퓨터로 수신되도록 하는 장비
    * 2계층 장비
        * 브리지: 두 개의 근거리통신망을 서로 연결해 주는 통신망 연결 장치
        * L2스위치: 느린 전송 속도의 브리지, 허브의 단점을 개선하기 위해서, 출발지에서 들어온 프레임을 목적지 MAC 주소 기반으로 빠르게 전송시키는 데이터 링크 계층의 통신 장치, 종류에 따라 3가지 방식 중 하나를 선택
            * Store and Forwarding: 데이터의 목적지 주소만 확인 후 바로 전송 처리하는 방식
            * Cut Through: 데이터의 목적지 주소만 확인 후 바로 전송 처리하는 방식
            * Fragment Free: 프레임의 앞 64바이트만을 읽어 에러를 처리하고 목적지 포트로 전송하는 방식
        * NIC: Network Interface Card의 약자, 외부 네트워크와 접속하여 가장 빠른 속도로 데이터를 주고받을수 있게 컴퓨터 내에 설치되는 장치
        * 스위칭 허브: 스위치 기능을 가진 허브, 사용되는 대부분의 허브가 스위칭 허브
    * 3계층 장비
        * 라우터: LAN과 LAN을 연결하거나 LAN과 WAN을 연결하기 위한 인터넷 네트워킹 장비, 패킷의 위치를 추출하여, 그 위치에 대한 최적의 경로를 지정하여, 이 경로를 따라 데이터 패킷을 다음 장치로 정송시키는 장비, 라우팅 프로토콜은 경로 설정을 하여 원하는 목적지까지 지정된 데이터가 안전하게 전달되도록 함
        * 게이트웨이: 프로토콜을 서로 다른 통신망에 접속할 수 있게 해주는 장치, LAN에서 다른 네트워크에 데이터를 보내거나 다른 네트워크로부터 데이터를 받아 들이는 출입구 역할
        * L3스위치: 3계층에서 네트워크 단위들을 연결하는 통신 장비, IP레이어에서의 스위칭을 수행하여 외부로 전송, 라우터와의 경계가 모호
        * 유무선 인터넷 공유기: 외부로부터 들어오는 인터넷 라인을 연결하여 유선으로 여러 대의 기계를 연결하거나 무선 신호로 송출하면서 여러 대의 컴퓨터가 하나의 인터넷 라인을 공유할 수 있도록 하는 네트워크 장비
        * 망(백본) 스위칭 허브: 광역 네트워크를 커버하는 스위칭 허브, 예를 들어 경남권 스위칭, 부산권 스위칭 등 대단원 지역을 커버함
    * 4계층 장비
        * L4스위치: 4계층에서 네트워크 단위들을 연결하는 통신 장비, TCP/UDP 등 스위치 수행, FTP/HTTP 등을 구분하여 스위칭하는 로드 밸런싱 가능, 애플리케이션 레이어에서 파악이 가능한 이메일 내용 등 정교한 로드 밸런싱 수행 불가, 4계층 정보인 TCP,UDP 포트번호를 분석하여 포워딩을 결정하고 QoSdhk GLB/SLB 기능을 제공하는 스위치
<br>

### 2. 프로토콜
* 개념
    * 서로 다른 시스템아나 기기들 간에 데이터 교환을 원활히 하기 위한 표준화된 통신규약
    * 컴퓨터가 메시지를 전달, 제대로 도착했는지 확인, 도착하지 않았을 경우 재전송하는 모든 '기술적 은어'
    * 데이터 처리 기능, 제어기능, 관리적 기능
<br>

* 기본 3요소
    * 구문(Syntax): 시스템 간의 정보 전송을 위한 데이터 형식, 코딩, 신호 레벨 등의 규정
    * 의미(Semantic): 시스템 간의 정보 전송을 위한 제어 정보로 조정과 에러 처리를 위한 규정
    * 타이밍(Timing): 시스템 간의 정보 전송을 위한 속도 조절과 순서 관리 규정
<br>

* 네트워크 프로토콜
    * 컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고받는 양식과 규칙의 체계
    * 전달 방식, 통신 방식, 자료의 형식, 오류 검증 방식, 코드 변화 규칙, 전송 속도 등을 정함
    * 다른 기종의 장비는 각각 다른 통신 규약을 사용하는데 프로토콜을 사용하면 다른 기기 간 정보의 전달을 표준화할 수 있음
    
    * 특징
        * 단편화: 전송이 가능한 작은 블록으로 나누어지는 기법
        * 재조립: 단편화되어 온 조각들을 원래 데이터로 복원하는 기법
        * 캡슐화: 상위 계층의 데이터에 각종 정보를 추가하여 하위 계층으로 보내는 기법
        * 연결 제어: 데이터의 전송량이나 속도를 제어하는 기법
        * 오류 제어: 전송 중 잃어버리는 데이터나 오류가 발생한 데이터를 검증하는 제어 기법
        * 동기화: 송신과 수신 측의 시점을 맞추는 기법
        * 다중화: 하나의 통신 회선에 여러 기기들이 접속할 수 있는 기술
        * 주소 지정: 송신과 수신지의 주소를 부여하여 정확한 데이터 전송을 보장하는 기법
<br>

* 데이터 링크 계층(2계층)
    * 링크의 설정, 유지, 종료를 담당
    * 노드 간의 회선 제어, 흐름 제어, 오류 제어 기능을 수행
        * 회선제어: 두 개의 스테이션이 동시에 신호를 전송하는 경우 신호 간 충돌이 발생하지 않도록 제어하는 기술 (ENQ/ACK기법, 풀링기법)
        * 흐름제어: 전송 스테이션으로 하여금 전송 데이터의 양을 제한하기 위해서 사용되는 기술 (정지-대기 기법, 슬라이딩 윈도우 기법)
        * 오류제어: OSI 7 Layer 하위의 두 계층 사이에서 데이터의 전송 오류를 검출하여 복구하는 기술 (해밍코드와 같은 전진오류수정(FEC)기법과 체크썸, CRC, ARQ과 같은 후진오류수정(BEC)) 

    * 프로토콜
    * HDLC(High-Level data link control): 점대점 방식이나 다중방식의 통신에 사용되는 ISO에서 표준화된 동기식 비트 중심 프로토콜
    * PPP(Point-To-Point-Protocol): 네트워크 분야에서 두 통신 노드 간의 직접적인 연결을 위해 일반적으로 사용
    * Frame Relay: 프로토콜 처리를 간략화하여 단순히 데이터 프레임들의 중계(Relay)기능과 다중화 기능만 수행함으로써 데이터 처리속도의 향상 및 전송지연을 감소시킨 소곳의 데이터 전송 기술
    * ATM(Asynchronous Transport Mode): 정보전달의 기본단위를 53바이트 셀 단위로 전달하는 비동기식 시분할 다중화 방식의 패킷형 전송 기술
<br>

* 네트워크 계층(3계층)
    * 다양한 길이의 패킷을 네트워크를 통해 전달하고, 그 과정에서 전송 계층이 요구하는 서비스품질을 위한 수단을 제공하는 계층
    * 라우팅, 패킷 포워딩, 인터 네트워킹

    * 프로토콜
    * IP(Internet Protocol): 송수신 간의 패킷 단위로 데이터를 교환하는 네트워크에서 정보를 주고받는데 사용
    * APR(Address Resolution Protocol): IP 네트워크 상에서 IP 주소를 MAC 주소로 변환하는 프로토콜
    * RARP(Reverse ~): IP 호스트가 자신이 물리 네트워크 주소는 알지만 IP 주소를 모르는 경우, 서버로부터 IP 주소를 요청하기 위해 사용하는 프로토콜
    * ICMP(Internet Control Message): IP 패킷을 처리할 대 발생되는 문제를 알려주는 프로토콜, 메시지 형식은 8바이트의 헤더와 가변 길이의 데이터 영역으로 분리, 수신지 도달 불가 메시지는 수신지 또는 서비스에 도달할 수 없는 호스트를 통지하는데 사용, ICMP 프로토콜을 사용해서 ping 유틸리티의 구현을 통해 오류가 발생했음을 알리는 기능을 수행
    * IGMP(Internet Group Management Protocol): 인터넷 그룹 관리 프로토콜, 호스트 컴퓨터와 인접 라우터가 멀티캐스트 그룹 멤버십을 구성하는 데 사용, 화상회의와 IP TV에서 활용, 그룹가입&멤버십감시&멤버십응답&멤버십탈퇴 기능
    * Routing Protocol: 데이터 전송을 위해 목적지까지 갈 수 있는 여러 경로 중 최적의 경로를 설정해주는 라우터 간의 상호 통신 프로토콜
<br>



* 응용 계층(7계층)
    * 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행하는 역할을 담당
    * 응용 프로세스가 개방된 형태로 다양한 범주위 정보처리기능을 수행할 수 있도록 여러 가지 프로토콜 개체에 대하여 사용자 인터페이스를 제공
    * 프로토콜
        * HTTP
        * FTP
        * SMTP
        * POP3
        * IMAP
        * Telnet
        * SSH
        * SNMP

### 3. 네트워크 전달 방식
1. 패킷 교환 방식(Packet Switching)
* 작은 블록의 패킷으로 데이터를 전송하고, 전송하는 동안만 네트워크 자원을 사용 (WAN)
    * 패킷: 데이터 단위라고 보면 됨
<br>

WAN을 통해 데이터를 원격지로 송부하기 위해 이용하는 기술들이다.
* X.25
    * 패킷 교환망을 통해 패킷을 원할히 전달하기 윈한 통신 프로토콜
    * ![img_21](https://user-images.githubusercontent.com/105165938/178635570-ef365c0f-d36a-49a8-b171-ab43b93cb161.png)
    *© 이미지 출처: Diagram of an X.25 network. All graphics were imported from the Open Clipart Library (http://www.openclipart.org/).*
    * 더 궁금하다면? <https://wonit.tistory.com/553>
* 프레임 릴레이
    * 
* ATM
    * 
<br>

2. 서킷 교환 방식(Circuit Switching)

<br>

3. 애드 훅 네트워크
<br>
<br>
<hr>

## Ch03 기본 개발환경 구축하기
### 1. 운영체제 설치 및 운용
#### 운영체제 선택
나중에 사야할 때가 오면, 구글링해서 찾아보자~
<br>

1. 윈도즈
    * 개인용
    * 기업용
    * 워크스테이션용
<br>

2. 리눅스
    * 데비안 계열<br>
        ![img_19](https://user-images.githubusercontent.com/105165938/178633927-14a9b0c7-59bc-43fd-8da6-d34d2f097c1c.png)
        * Debian GNU/Linux: 개발자 패키지, 매뉴얼이 있어 개발자에게 최적화
        * Ubuntu: 가장 광범위하게 사용, 다양한 개발자용 패키지, SW Center를 통해 응용 소프트웨어 공급
            * 개발자용 패키지
            * 응용 소프트웨어
    * Redhat 계열<br>
        ![img_20](https://user-images.githubusercontent.com/105165938/178634475-86e6924d-5045-4015-9272-f2e500501893.png)
        * Fedora: 스마트 설정, 업데이트로 사용자 편의성
        * 안정화된 운영 및 다양한 하드웨어 지원
    * 기타
        * OpenSUSE: 안정화된 버전(openSUSE)과 테스트 중인 버전(Tumbleweed)을 동시 공급, 테스즈 자동화 지원 (by YaST 패키지)
        * Slackware: 다양한 SW, GUI 미리 설치됨 (시스템 관리자: 복구 툴 내장)
<br>
<br>

#### 운영체제 운용
* 외부 침입, 바이러스로 인해 시스템이 통제 불능의 상태가 되지 않도록 지속적인 운용이 필요하다.
<br>

1. 서버 운영체제 운용 기준
    * 운용 아키텍처 및 기능 파악
    * 네트워크 구성 현황 및 장비 메뉴얼 확보
    * 장비 가동 및 중지 매뉴얼 확인
    * 백업 주기, 보안 업데이트 주기 설정 및 점검
    * 트러블 발생 시 대처 방안 마련
<br>

2. 개별 PC용 운영체제 운용 기준
    * 정기적인 데이터 백업
    * 주기적 보안 업데이트
    * 시스템 백업 정례화
    * 트러블 발생 시 문의처 정보 확인
<br>
<br>

### 2. 개발 도구 설치 및 운용
#### 프로그래밍 언어
다양한 프로그래밍 언어를 선택하는 것은 시스템 개발 및 운영에 매우 중요합니다.
<br>

* 고려사항
    * 언어 타입: 정적 | 동적 개발언어
    * 시스템 특징: 일반 | 도메인 특화 시스템
    * 언어 특징
        * 객체 지향 (재사용성 좋음)
        * 순차적 (재사용 불가)
        * 명령형: 문제를 해결하기 위한 방법을 기술
        * 선언형: 프로그램이 수행해야 하는 문제를 기술 (가독성 좋음, 오류 적음)<br>
        ![img_17](https://user-images.githubusercontent.com/105165938/178625837-f4cec174-731b-4ef4-935b-5e7a9229b79d.jpeg)<br>
    * 지원
        * 관리 도구 지원형
        * 언어 독립형
<br>


#### 개발 지원 도구
* 개발 과정을 관리할 때 오픈 소스 기반의 도구를 활용하여 작업의 생산성을 높이는 것이 탁월하다.
<br>

* 요구사항 관리: 프로젝트 수행 시 정확한 요구사항 정의 및 관리 (JFeature)
* 설계: ERD를 통한 자동화된 데이터 모델링, UML 자동 생성 (DBdesigner)
* 구현: 개발자의 SW 구현 시 개발자 편의성 고려 (Eclipse, CodeBlock)
* 테스트: 지속적 통합 기반, 자동 테스트 수행 (jUnit)
* 빌드: SW 빌드 자동화, 스크립트를 통한 빌드 자동화 (Ant, <span style="olor:#ff739f">Jenkins</span>)
* 형상관리: 개발 산출물 관리 (Subversion)
* 품질 관리: 설계품질의 측정을 통해 패키지를 효과적으로 분석하고 관리 (jDepend, Mylyn)
* 이슈 관리: 프로젝트를 진행하면서 발생하는 문제를 시스템에 등록하여 관리 (Mantis, Git)
* 프로젝트 관리: 간트 차트(일정 관리), 네트워크 다이어그램, WBS (Readmine, OpenProj)
<br>
<br>

### 3. 응용 시스템 개발 인프라 구축
#### 개발환경 인프라 구축
* 우리는 개발하기 전에 전체 시스템에 필요로 하는 서비스를 효율적으로 선택하여 개발환경을 구축할 수 있어야 합니다.
<br>

* 구성 방식
    * 온프레미스 방식(On-Premise)
        * **외부 인터넷망이 차단된 상태**에서 인트라넷망만을 활용하여 개발환경을 구축
        * 데이터와 정보의 외부 유출이 민감할 경우 해당 장비를 자체 구매하고 특정 공간에 개발환경을 구축
    * 클라우드 방식(Cloud)
        * 아마존, 구글, 마이크로소프트 등 클라우드 공급 서비스를 하는 회사들의 서비스를 임대하여 개발환경을 구축
        * 해당 장비를 초기에 구매하지 않기 때문에 개발환경 투자비용이 적고 구축 시간이 빠름
    * 하이브리드 방식(Hybrid)
        * 온프레미스 + 클라우드
<br>

* 고려 사항
> 인프라를 구축하기 전에 고려해보자.<br>
> * 개발하려는 목표 시스템을 완벽히 이해하고 있는가?
> * 로컬 개발 환경과 운영환경이 명확히 구분되어 개발 소스가 충돌하지 않는가?
> * 개발 서버는 계층화되어 있어 검증되어 안정화된 소스와 개발 중인 불안전한 소스가 구분되도록 고려되었는가?
> * 서비스의 안정적인 운영을 위해 지속적인 테스트와 신속한 배포가 가능하도록 설계되었는가?
> * 운영비가 급격히 상승하여 비용적인 부담이 될 수 있는 가능성이 있는가?
> * 서비스의 규모가 커질 경우 확장성이 충분히 고려되어 있는가?
> * 오픈 소스 활용 시 커뮤니티를 활용하기 위한 환경이 구축되어 있는가?
> * 개발에 참여가히 위한 다수의 인원이 참조할 수있는 표준화가 마련되었는가?


#### 클라우드 기반 인프라 구축
사용자가 서비스의 범위와 사용량에 따른 비용만 지불하면, 서비스 제공자가 이중화된 클라우드 센터를 운영하여 안정적인 서비스를 공급합니다. 
* 서비스는 장비 임대, 스토리지 대여, 개발자 도구, 생상성 향상을 위한 각종 유틸리티 등이 있습니다.
<br>

* 제공 범위
    * 컴퓨팅 환경
        * 프로그램을 설치하고 운용할 하드웨어 장비 세팅
        * 웹서버
        * DBMS 서버
        <br>
        <br>
    * 스토리지
        * 대규모 데이터를 저장, 관리, 전송, 이중화하기 위한 저장 장치 세팅
        * 클라우드 기반 스토리지 세팅
        * 아카이브 스토리지 세팅 (데이터 안정성 향상을 위함)
        * 전송 스트로지 세팅 (페타/엑사 바이트 단위 전송 가능)
    * 데이터베이스
        * DB 세팅
        * 고성능 RDB 세팅
        * in-memory DB 세팅
            * IOT 발달로 필요도 급상승, 실시간 데이터 처리에 유리 (HDD(X), SDD(X), RAM(O)) <br> 
        ![img_18](https://user-images.githubusercontent.com/105165938/178626798-dc4ea6bf-97dc-4b74-bfbc-8be4dcec27d7.png)
        * warehousing 세팅 (대규모 데이터 운영에 필요)
        * graphic, multi-data 처리를 위한 환경 세팅
    * 네트워킹 전송
        * 구성된 서비스, 프로그램, 콘텐츠를 효율적으로 전달하기 위한 환경 세팅
        * 콘텐츠 전송용 CDN 구축
            * CDN(Contents Delivery Network): 콘텐츠를 효율적으로 전달하기 위해 __여러 노드를 가진 네트워크에 데이터를 저장__하여 제공하는 시스템
        * API 제공용 환경 구축
        * 대규모 로드 밸런싱 환경 구축
    * 개발자 도구
        * 제반 환경 구축 (실제 프로그램 개발)
        * 애플리케이션 개발 및 배포환경 구축
        * 소스 코드를 손실 없이 관리하기 위한 저장소 구축
        * 코드 개발, 테스트를 위한 환경 구축
        * 코드 자동 배포, 형상 관리를 위한 환경 구축
    * 보안 환경 구축
        * 외부의 침입으로부터 시스템과 데이터를 보호하기 위한 환경 구축
        * 사용자 엑세스 및 암호화 관리
        * 앱 자격 증명 환경 구축
        * 각종 인증서 프로비저닝, 관리 및 배포
        * 악성 트래픽 필터링 서비스 관리
        * 해킹 공격으로부터의 방어 환경 구축
    * 응용 기술 세팅
        * AR, VR 개발을 위한 환경 세팅
        * AI 개발 환경을 위한 환경 세팅
        * IOT, 게임 개발을 위한 환경 세팅
    * 생상성 향상
        * 시스템 볼륨 자동 확장 환경 구축
        * 실시간 스트리밍 서비스 환경 구축
        * 비즈니스, 운영 상태 분석 서비스 구축